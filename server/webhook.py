# server/webhook.py
from __future__ import annotations

import os
import json
import logging
from datetime import datetime, timezone
from typing import Optional, Dict, Any

import stripe
from fastapi import FastAPI, Request, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, EmailStr, Field
from sqlalchemy import select, update
from sqlalchemy.ext.asyncio import AsyncSession

from .db import get_session
from .models import User, Subscription, Summary

logger = logging.getLogger("ai-report-backend")
logging.basicConfig(level=logging.INFO)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # tighten later
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ----------------------------
# ENV
# ----------------------------
STRIPE_SECRET_KEY = os.getenv("STRIPE_SECRET_KEY", "").strip()
STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET", "").strip()

STRIPE_PRICE_BASIC = os.getenv("STRIPE_PRICE_BASIC", "").strip()
STRIPE_PRICE_PRO = os.getenv("STRIPE_PRICE_PRO", "").strip()
STRIPE_PRICE_ENTERPRISE = os.getenv("STRIPE_PRICE_ENTERPRISE", "").strip()

SUCCESS_URL = os.getenv("SUCCESS_URL", "").strip()
CANCEL_URL = os.getenv("CANCEL_URL", "").strip()

stripe.api_key = STRIPE_SECRET_KEY

PRICE_TO_PLAN = {
    STRIPE_PRICE_BASIC: "basic",
    STRIPE_PRICE_PRO: "pro",
    STRIPE_PRICE_ENTERPRISE: "enterprise",
}

# ----------------------------
# Helpers (DB)
# ----------------------------
async def get_or_create_user(session: AsyncSession, email: str) -> User:
    email_norm = email.strip().lower()
    res = await session.execute(select(User).where(User.email == email_norm))
    user = res.scalar_one_or_none()
    if user:
        return user

    user = User(email=email_norm)  # id is generated by DB default gen_random_uuid()
    session.add(user)
    await session.flush()  # populate user.id
    return user


def to_dt_from_unix(ts: Optional[int]) -> Optional[datetime]:
    if not ts:
        return None
    return datetime.fromtimestamp(int(ts), tz=timezone.utc)


# ----------------------------
# API Models
# ----------------------------
class CheckoutRequest(BaseModel):
    email: EmailStr
    plan: str = Field(..., description="basic|pro|enterprise")


class CheckoutResponse(BaseModel):
    url: str
    session_id: str


class GenerateSummaryRequest(BaseModel):
    email: EmailStr
    input_type: str = Field(..., description="pdf|text|docx|other")
    input_name: Optional[str] = None
    text: str = Field(..., description="Raw extracted text (or user-entered)")
    summary_text: str = Field(..., description="The final summary you produced")
    tokens_used: int = 0


# ----------------------------
# Routes
# ----------------------------
@app.get("/health")
async def health():
    return {"ok": True}


@app.post("/create-checkout-session", response_model=CheckoutResponse)
async def create_checkout_session(
    payload: CheckoutRequest,
    session: AsyncSession = Depends(get_session),
):
    if not STRIPE_SECRET_KEY:
        raise HTTPException(status_code=500, detail="STRIPE_SECRET_KEY not set")

    plan = payload.plan.strip().lower()
    price_id = None
    if plan == "basic":
        price_id = STRIPE_PRICE_BASIC
    elif plan == "pro":
        price_id = STRIPE_PRICE_PRO
    elif plan == "enterprise":
        price_id = STRIPE_PRICE_ENTERPRISE

    if not price_id:
        raise HTTPException(status_code=400, detail="Invalid plan or missing STRIPE_PRICE_*")

    if not SUCCESS_URL or not CANCEL_URL:
        raise HTTPException(status_code=500, detail="SUCCESS_URL / CANCEL_URL not set")

    # ensure user exists in DB
    user = await get_or_create_user(session, str(payload.email))
    await session.commit()

    checkout = stripe.checkout.Session.create(
        mode="subscription",
        customer_email=str(payload.email),
        allow_promotion_codes=True,  # enables coupon box
        line_items=[{"price": price_id, "quantity": 1}],
        success_url=SUCCESS_URL,
        cancel_url=CANCEL_URL,
        metadata={
            "user_id": str(user.id),
            "email": str(payload.email).lower(),
            "plan": plan,
        },
    )

    return CheckoutResponse(url=checkout.url, session_id=checkout.id)


@app.post("/stripe-webhook")
async def stripe_webhook(
    request: Request,
    session: AsyncSession = Depends(get_session),
):
    if not STRIPE_WEBHOOK_SECRET:
        raise HTTPException(status_code=500, detail="STRIPE_WEBHOOK_SECRET not set")

    payload = await request.body()
    sig = request.headers.get("stripe-signature")

    try:
        event = stripe.Webhook.construct_event(payload, sig, STRIPE_WEBHOOK_SECRET)
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Webhook signature error: {e}")

    event_type = event["type"]
    obj = event["data"]["object"]

    # ----------------------------
    # checkout.session.completed (subscription created)
    # ----------------------------
    if event_type == "checkout.session.completed":
        email = (obj.get("customer_details", {}) or {}).get("email") or obj.get("customer_email")
        customer_id = obj.get("customer")
        subscription_id = obj.get("subscription")
        metadata = obj.get("metadata", {}) or {}

        if not email:
            logger.warning("checkout.session.completed missing email")
            return {"received": True}

        user = await get_or_create_user(session, email)

        # Pull subscription details to capture price/status/period_end
        sub = None
        try:
            if subscription_id:
                sub = stripe.Subscription.retrieve(subscription_id)
        except Exception:
            logger.exception("Failed to retrieve subscription from Stripe")

        price_id = None
        status = None
        current_period_end = None

        if sub:
            status = sub.get("status")
            current_period_end = to_dt_from_unix(sub.get("current_period_end"))
            items = (sub.get("items", {}) or {}).get("data", []) or []
            if items and items[0].get("price"):
                price_id = items[0]["price"].get("id")

        plan = PRICE_TO_PLAN.get(price_id, (metadata.get("plan") or "unknown"))

        # Upsert into your subscriptions table by subscription_id (you added unique constraint)
        # NOTE: using ORM approach since ON CONFLICT is SQL-level
        res = await session.execute(
            select(Subscription).where(Subscription.subscription_id == str(subscription_id))
        )
        row = res.scalar_one_or_none()

        if not row:
            row = Subscription(
                customer_id=str(customer_id) if customer_id else None,
                email=str(email).lower(),
                subscription_id=str(subscription_id) if subscription_id else None,
                price_id=price_id,
                status=status,
                current_period_end=current_period_end,
                user_id=str(user.id),
            )
            session.add(row)
        else:
            row.customer_id = str(customer_id) if customer_id else row.customer_id
            row.email = str(email).lower()
            row.price_id = price_id or row.price_id
            row.status = status or row.status
            row.current_period_end = current_period_end or row.current_period_end
            row.user_id = str(user.id)

        await session.commit()
        return {"received": True}

    # ----------------------------
    # customer.subscription.updated / deleted
    # ----------------------------
    if event_type in ("customer.subscription.updated", "customer.subscription.deleted"):
        subscription_id = obj.get("id")
        customer_id = obj.get("customer")
        status = obj.get("status")
        current_period_end = to_dt_from_unix(obj.get("current_period_end"))

        items = (obj.get("items", {}) or {}).get("data", []) or []
        price_id = None
        if items and items[0].get("price"):
            price_id = items[0]["price"].get("id")

        # update the subscriptions row if it exists
        res = await session.execute(
            select(Subscription).where(Subscription.subscription_id == str(subscription_id))
        )
        row = res.scalar_one_or_none()
        if row:
            row.customer_id = str(customer_id) if customer_id else row.customer_id
            row.status = status or row.status
            row.price_id = price_id or row.price_id
            row.current_period_end = current_period_end or row.current_period_end
            await session.commit()

        return {"received": True}

    # ignore other events
    return {"received": True}


@app.post("/generate-summary")
async def generate_summary(
    payload: GenerateSummaryRequest,
    session: AsyncSession = Depends(get_session),
):
    """
    This endpoint is mainly for *storing* the generated summary.
    Your Streamlit app can:
      1) generate summary text however it wants
      2) POST it here to persist in Postgres
    """
    user = await get_or_create_user(session, str(payload.email))

    # find latest subscription for this user (optional)
    res = await session.execute(
        select(Subscription)
        .where(Subscription.user_id == str(user.id))
        .order_by(Subscription.id.desc())
        .limit(1)
    )
    sub = res.scalar_one_or_none()

    row = Summary(
        user_id=str(user.id),
        subscription_id=sub.id if sub else None,
        input_type=payload.input_type,
        input_name=payload.input_name,
        summary_text=payload.summary_text,
        tokens_used=int(payload.tokens_used or 0),
    )
    session.add(row)
    await session.commit()

    return {
        "ok": True,
        "user_id": str(user.id),
        "subscription_id": sub.subscription_id if sub else None,
    }


@app.get("/subscription-status")
async def subscription_status(email: EmailStr, session: AsyncSession = Depends(get_session)):
    email_norm = str(email).strip().lower()

    res = await session.execute(select(User).where(User.email == email_norm))
    user = res.scalar_one_or_none()
    if not user:
        return {"email": email_norm, "has_active_subscription": False, "status": "none", "plan": "none"}

    res = await session.execute(
        select(Subscription)
        .where(Subscription.user_id == str(user.id))
        .order_by(Subscription.id.desc())
        .limit(1)
    )
    sub = res.scalar_one_or_none()
    if not sub:
        return {"email": email_norm, "has_active_subscription": False, "status": "none", "plan": "none"}

    plan = PRICE_TO_PLAN.get(sub.price_id or "", "unknown")
    has_active = (sub.status == "active")

    return {
        "email": email_norm,
        "has_active_subscription": has_active,
        "plan": plan,
        "status": sub.status,
        "current_period_end": int(sub.current_period_end.timestamp()) if sub.current_period_end else None,
        "stripe_customer_id": sub.customer_id,
        "stripe_subscription_id": sub.subscription_id,
        "user_id": sub.user_id,
    }
